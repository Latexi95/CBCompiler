//http://www.coolbasic.com/phpBB3/viewtopic.php?f=12&t=697&start=320#p41458
 
Const screenw% = 300
Const screenh% = 300
 
fov=35
maxiters=8
 
SCREEN screenw, screenh
 
Type sphere
    Field x#
    Field y#
    Field z#
    Field ox#
    Field oy#
    Field oz#
    Field w#
    Field r#
    Field g#
    Field b#
    Field specularity#
    Field diffuse#
EndType
 
struct ColorVec
    Field r#
    Field g#
    Field b#
EndStruct
 
Type light
    Field x#
    Field y#
    Field z#
EndType
 
s As sphere = New(sphere)
s.ox# = -1: s.oy# = -1: s.oz# = 7: s.w# = 1.5: s.r# = 255: s.g#= 0: s.b# = 0:s.diffuse#=0.9
 
s as sphere = New(sphere)
s.ox# = 2: s.oy# = 1: s.oz# = 6: s.w# = 1: s.r# = 5: s.g# = 0: s.b# = 255:s.diffuse#=0.8
 
s as sphere = New(sphere)
s.ox# = 0: s.oy# = 1.5: s.oz# = 7: s.w# = 1: s.r# = 5: s.g# = 255: s.b# = 0:s.diffuse#=0.8
 
 
l As light = New(light)
l.x = -3: l.y = 0: l.z = 0
 
cv as ColorVec// use single struct
 
global ambient as ColorVec
ambient.r=100:ambient.g=100:ambient.b=100
 
Repeat
    Tim=Timer()
    fovc#=Tan(fov/2)/Cos(fov/2)'sama kulma joka resolla(pystysuunnassa)
 
    t# = t# + (Timer() - lastUpdate) / 100.0
    lastUpdate = Timer()
    t2# = t#
    For s As sphere = Each sphere
        s.x# = s.ox# + Sin(t2# * 2.0) * 0.7
        s.y# = s.oy# + Sin(t2# * 1.4 +124124) * 0.3
        s.z# = s.oz# + Sin(t2# + 343) * 0.6
        t2# = t2# + t#
        s.specularity#=sin(timer()/20.0)*0.4+0.5
    Next s
    lock2(2) //writeonly
    For x#=0 To screenw-1
        For y#=0 To screenh-1
            col as ColorVec=trace(cv,0,0,0,fovc*(x/screenh-0.5*screenw/screenh)*2.0,fovc*(y/screenh-0.5)*2.0,1,maxiters)
            r as Byte = int(Min(255.0,col.r))
            g as Byte = int(Min(255.0,col.g))
            b as Byte= int(Min(255.0,col.b))
            //Color  r, g, b
            putpixel int(x),int(y),r,g,b
        Next y#
    Next x#
    unlock
    DrawScreen
    Print (Timer()-Tim)
Forever
 
Function trace(cv as ColorVec,x#,y#,z#,vx#,vy#,vz#,iters) As ColorVec
    coll=0
    For obj as sphere=Each sphere
        Q# = Sqrt(vx#*vx# + vy#*vy# + vz#*vz#)
        dx = dx / Q: dy = dy / Q: dz = dz / Q
       
        a# = vx#*vx# + vy#*vy# + vz#*vz#
        b# = 2*vx#*(x#-obj.x#) + 2*vy#*(y#-obj.y) + 2*vz#*(z#-obj.z#)
        c# = obj.x#*obj.x# + obj.y#*obj.y# + obj.z#*obj.z# + x*x + y*y + z*z -2*(obj.x# * x# + obj.y# * y# + obj.z#*z#) - obj.w#*obj.w#
        d# = b#*b# - 4*a#*c#
        If d>0 Then
            tt# = (-b#-Sqrt(d#))/(2*a#)
            If (coll==0 Or dist#>tt) And tt>0.0001
                dist#=tt
                nearest As sphere=obj
                coll=1
            EndIf
        EndIf
    Next obj
   
    If coll Then
        obj As sphere=nearest
        //valaistus
        'remstart
        For valo As light=Each light
            pvx#=obj.x-x-vx*dist
            vvx#=valo.x-x-vx*dist
            pvy#=obj.y-y-vy*dist
            vvy#=valo.y-y-vy*dist
            pvz#=obj.z-z-vz*dist
            vvz#=valo.z-z-vz*dist
            pvl#=Sqrt(pvx*pvx+pvy*pvy+pvz*pvz)
            vvl#=Sqrt(vvx*vvx+vvy*vvy+vvz*vvz)
            pvx#=pvx/pvl
            vvx#=-vvx/vvl
            pvy#=pvy/pvl
            vvy#=-vvy/vvl
            pvz#=pvz/pvl
            vvz#=-vvz/vvl
            dp#=pvx*vvx+pvy*vvy+pvz*vvz
            lightness#=lightness+Max(0.0,dp)
            specular#=specular+Max(0.0,dp)^8*0.5 //a hack for more interresting specular
            dp#=pvx*vx+pvy*vy+pvz*vz
            svx#=(2*dp*pvx-vx)
            svy#=(2*dp*pvy-vy)
            svz#=(2*dp*pvz-vz)
            specular#=max(0.0,(vvx*svx+vvy*svy+vvz*svz))^2/2.0+specular
        Next valo
        'remend
        //heijastukset
        If iters>0 Then
            pvx#=obj.x-x-vx*dist
            pvy#=obj.y-y-vy*dist
            pvz#=obj.z-z-vz*dist
            pvl#=Sqrt(pvx^2+pvy^2+pvz^2)
            pvx#=pvx/pvl
            pvy#=pvy/pvl
            pvz#=pvz/pvl
            dp#=pvx*vx+pvy*vy+pvz*vz
            svx#=-(2*dp*pvx-vx)
            svy#=-(2*dp*pvy-vy)
            svz#=-(2*dp*pvz-vz)
            cv=trace(cv,x#+vx*dist,y#+vy*dist,z#+vz*dist,svx,svy,svz,iters-1)
        Else
            cv=ambient//cv.r=0:cv.g=0:cv.b=0
        EndIf
        diffuse#=(1.0-obj.specularity)*obj.diffuse
        cv.r=(obj.r*lightness+ambient.r)*diffuse+(cv.r+specular*255)*obj.specularity //+20'*dotp
        cv.g=(obj.g*lightness+ambient.g)*diffuse+(cv.g+specular*255)*obj.specularity //+20'*dotp
        cv.b=(obj.b*lightness+ambient.b)*diffuse+(cv.b+specular*255)*obj.specularity //+20'*dotp
    Else
        cv=ambient//cv.r=ambient.r:cv.g=100:cv.b=100
    EndIf
    Return cv
EndFunction
