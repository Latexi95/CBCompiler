//http://www.coolbasic.com/phpBB3/viewtopic.php?f=12&t=697&start=320#p41458

Const screenw% = 300
Const screenh% = 300
 
fov=35
maxiters=8
 
SCREEN screenw, screenh
 
Struct ColorVec
    Field r#
    Field g#
    Field b#
EndStruct

Struct Vec
    Field x#
    Field y#
    Field z#
EndStruct

Type sphere
    Field pos as Vec
    Field origin as Vec
    Field size#
    Field c as ColorVec
    Field specularity#
    Field diffuse#
EndType

Type light
    Field pos As Vec
EndType


function newColorVec(r#,g#,b#) as ColorVec
    cv as ColorVec
    cv.r#=r#:cv.g#=g#:cv.b#=b#
    return cv
endfunction

function newVec(x#,y#,z#) as Vec
    v as Vec
    v.x#=x#:v.y#=y#:v.z#=z#
    return v
endfunction

function vecLength(v as Vec) as Float
    return Sqrt(v.x*v.x+v.y*v.y+v.z*v.z)
endfunction

function vecDot(v as Vec) as Float
    return v.x+v.y+v.z
endFunction

function vecMul(v1 as Vec, v2 as Vec) as Vec
    return newVec(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z)
endFunction

function vecMul(v1 as Vec, s as Float) as Vec
    return newVec(v1.x*s, v1.y*s, v1.z*s)
endFunction

function vecMul(s as Float,v1 as Vec) as Vec
    return newVec(v1.x*s, v1.y*s, v1.z*s)
endFunction

function vecSum(v1 as Vec, v2 as Vec) as Vec
    return newVec(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z)
endFunction

function vecSub(v1 as Vec, v2 as Vec) as Vec
    return newVec(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z)
endFunction

function vecSub(v1 as Vec, s as Integer) as Vec
    return newVec(v1.x-s, v1.y-s, v1.z-s)
endFunction

function vecSub(s as Integer, v1 as Vec) as Vec
    return newVec(s-v1.x, s-v1.y, s-v1.z)
endFunction

function vecNegate(v as Vec) as Vec
    return newVec(-v.x, -v.y, -v.z)
endFunction

function normalize(v as Vec) as Vec
    return vecMul(v,1.0/vecLength(v))
endfunction


function newSphere(x#,y#,z#,size#,r#,g#,b#,diffuse#) as Sphere
    s As sphere = New(sphere)
    s.origin=newVec(x#,y#,z#)
    s.size# = size#
    s.c=newColorVec(r#,g#,b#)
    s.diffuse#=diffuse
    return s
endfunction

function newLight(x#,y#,z#) as Light
    l As Light = New(Light)
    l.pos=newVec(x#,y#,z#)
    return l
endfunction


newSphere(-1,-1,7,  1.5,    255,0,0, 0.9)
newSphere(2,1,6,    1,      5,0,255, 0.8)
newSphere(0,1.5,7,  1,      5,205,0, 0.8)
newLight(-3,0,0)


cv as ColorVec// use single struct
global ambient as ColorVec = newColorVec(40,100,100)

lastUpdate=0

Repeat
    Tim=Timer()
    fovc#=Tan(fov/2)/Cos(fov/2)'sama kulma joka resolla(pystysuunnassa)

    t# = t# + (Timer() - lastUpdate) / 100.0
    lastUpdate = Timer()
    t2# = t#

    For s As sphere = Each sphere
        s.pos.x# = s.origin.x# + Sin(t2# * 2.0) * 0.7
        s.pos.y# = s.origin.y# + Sin(t2# * 1.4 +124124) * 0.3
        s.pos.z# = s.origin.z# + Sin(t2# + 343) * 0.6
        t2# = t2# + t#
        s.specularity#=sin(timer()/20.0)*0.4+0.5
    Next s

    l as light = first(light)
    l.pos.x=sin(t*9.0)*10

    lock2(2) //writeonly lock
    For x#=0 To screenw-1
        For y#=0 To screenh-1
            campos as Vec = newVec(0,0,0)
            raydir as Vec = newVec(fovc*(float(x)/screenh-0.5*screenw/screenh)*2.0,fovc*(float(y)/screenh-0.5)*2.0,1)
            col as ColorVec=trace(cv,campos,raydir,maxiters)
            r as Byte = min(255,col.r)
            g as Byte = min(255,col.g)
            b as Byte = min(255,col.b)

            putpixel x,y,r,g,b
        Next
    Next
    unlock
    DrawScreen
    Print (Timer()-Tim)+" "+FPS()
Forever

Function trace(cv as ColorVec, ray as Vec, dir as Vec, iters) As ColorVec
    coll=0
    dir=normalize(dir)
    For obj as sphere=Each sphere
        b# = 2*vecDot(vecMul(dir,vecSub(ray,obj.pos)))
        c# = vecDot(vecMul(obj.pos,obj.pos)) + vecDot(vecMul(ray,ray)) -2*vecDot(vecMul(obj.pos,ray)) - obj.size#*obj.size#
        d# = b#*b# - 4*c#
        If d>0 Then
            tt# = (-b#-Sqrt(d#))/2
            If (coll==0 Or dist#>tt) And tt>0.0001
                dist#=tt
                nearest As sphere=obj
                coll=1
            EndIf
        EndIf
    Next obj

    If coll Then
        obj As sphere=nearest
        camdir as Vec = normalize(vecSub(vecSub(obj.pos,ray),vecMul(dir,dist)))
        specularDir as Vec = vecSub(vecMul(2*vecDot(vecMul(camDir,dir)),camDir),dir)
        //valaistus
        specular#=0
        diffuse#=0
        For valo As light=Each light
            lightdir as Vec = vecNegate(normalize(vecSub(vecSub(valo.pos,ray),vecMul(dir,dist))))
            diffuCos#=vecDot(vecMul(camDir,lightDir))
            diffuse#=diffuse+Max(0.0,diffuCos)
            specular#=specular+Max(0.0,diffuCos)^8*0.5 //a hack for more interresting specular
            specular#=max(0.0,vecDot(vecMul(lightdir,specularDir)))^12/2.0+specular
        Next valo
        //heijastukset
        If iters>0 Then
            pos as Vec = vecSum(ray,vecMul(dir,dist))
            dir as Vec = vecNegate(speculardir)
            cv=trace(cv,pos,dir,iters-1)
        Else
            cv=ambient
        EndIf
        diffuseAmount#=(1.0-obj.specularity)*obj.diffuse
        cv.r=(obj.c.r*diffuse+ambient.r)*diffuseAmount+(cv.r+specular*255)*obj.specularity
        cv.g=(obj.c.g*diffuse+ambient.g)*diffuseAmount+(cv.g+specular*255)*obj.specularity
        cv.b=(obj.c.b*diffuse+ambient.b)*diffuseAmount+(cv.b+specular*255)*obj.specularity
    Else
        cv=ambient
    EndIf
    Return cv
EndFunction
