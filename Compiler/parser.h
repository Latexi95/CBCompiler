#ifndef PARSER_H
#define PARSER_H
#include <QObject>
#include "settings.h"
#include "token.h"
#include "abstractsyntaxtree.h"

/**
 * @brief The Parser class parses a token list generated by Lexer and produces an abstract syntax tree.
 */
class Parser : public QObject {
		Q_OBJECT
	public:
		typedef QList<Token>::ConstIterator TokIterator;
		Parser();

		/**
		 * @brief parse Parses a token list and generates an AST
		 * @param tokens Token list
		 * @return The abstract syntax tree generated
		 */
		ast::Program *parse(const QList<Token> &tokens, const Settings &settings);

		/**
		 * @brief success
		 * @return True, if parsing succeeded, false otherwise.
		 */
		bool success() {return mStatus == Ok;}

		ast::Node *tryConstDefinition(TokIterator &i);
		ast::Node *tryGlobalDefinition(TokIterator &i);
		ast::Node *tryVariableTypeDefinition(TokIterator &i);
		ast::Node *tryVariableTypeMark(TokIterator &i);
		ast::Node *tryVariableAsType(TokIterator &i);
		ast::Node *tryReturn(TokIterator &i);
		ast::TypeDefinition *tryTypeDefinition(TokIterator &i);
		ast::StructDefinition *tryStructDefinition(TokIterator &i);
		ast::Variable *expectVariable(TokIterator &i);
		ast::Variable *tryVariable(TokIterator &i);
		ast::Node *expectVariableOrIdentifier(TokIterator &i);
		ast::Node *trySelectStatement(TokIterator &i);
		ast::Node *tryGotoGosubAndLabel(TokIterator &i);
		ast::Node *tryRedim(TokIterator &i);
		ast::Node *tryDim(TokIterator &i);
		ast::Node *tryIfStatement(TokIterator &i);
		ast::Node *expectIfStatementNoKeyword(const CodePoint& startCp, TokIterator &i);
		ast::Node *expectElseIfStatement(TokIterator &i);
		ast::Node *tryWhileStatement(TokIterator &i);
		ast::Node *tryRepeatStatement(TokIterator &i);
		ast::Node *tryForStatement(TokIterator &i);
		ast::Node *tryExit(TokIterator &i);
		ast::Node *expectBlock(TokIterator &i);
		ast::Node *expectInlineBlock(TokIterator &i);
		ast::Node *tryExpression(TokIterator &i);

		ast::FunctionDefinition *tryFunctionDefinition(TokIterator &i);

		ast::Node *expectExpressionList(TokIterator &i);
		ast::Node *expectCommandCall(TokIterator &i);

		ast::Node *expectVariableDefinitionList(TokIterator &i);
		ast::Node *expectFunctionParameterList(TokIterator &i);
		ast::Node *expectVariableDefinition(TokIterator &i);
		ast::Node *expectVariableDefinitionOrArrayInitialization(TokIterator &i);

		ast::Node *expectExpression(TokIterator &i);
		ast::Node *expectAssignementExpression(TokIterator &i);
		ast::Node *expectLogicalOrExpression(TokIterator &i);
		ast::Node *expectLogicalAndExpression(TokIterator &i);
		ast::Node *expectEqualityExpression(TokIterator &i);
		ast::Node *expectRelativeExpression(TokIterator &i);
		ast::Node *expectBitShiftExpression(TokIterator &i);
		ast::Node *expectAdditiveExpression(TokIterator &i);
		ast::Node *expectMultiplicativeExpression(TokIterator &i);
		ast::Node *expectPowExpression(TokIterator &i);
		ast::Node *expectUnaryExpession(TokIterator &i);
		ast::Node *expectCallOrArraySubscriptExpression(TokIterator &i);
		ast::Node *tryNegativeLiteral(TokIterator &i);
		ast::Node *expectPrimaryExpression(TokIterator &i);
		ast::Identifier *expectIdentifier(TokIterator &i);
		ast::Identifier *expectIdentifierAfter(TokIterator &i, const QString &after);

		ast::ArrayInitialization *expectArrayInitialization(TokIterator &i);

		bool expectLeftParenthese(TokIterator &i);
		bool expectRightParenthese(TokIterator &i);

		bool expectLeftSquareBracket(TokIterator &i);
		bool expectRightSquareBracket(TokIterator &i);

		ast::Node *expectPrimaryTypeDefinition(TokIterator &i);
		ast::Node *expectArrayTypeDefinition(TokIterator &i);
		ast::Node *expectVariableTypeDefinition(TokIterator &i);

		void expectEndOfStatement(TokIterator &i);

		bool variableTypesAreEqual(ast::Node *a, ast::Node *b);

		bool isCommandParameterList(TokIterator i);
	private:
		enum Status {
			Error,
			ErrorButContinue,
			Ok
		};

		Status mStatus;
		Settings mSettings;
	signals:
		void error(int code, QString msg, CodePoint cp);
		void warning(int code, QString msg, CodePoint cp);
};

#endif // PARSER_H
